// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: echoWave.proto

#ifndef PROTOBUF_echoWave_2eproto__INCLUDED
#define PROTOBUF_echoWave_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3000000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3000000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_echoWave_2eproto();
void protobuf_AssignDesc_echoWave_2eproto();
void protobuf_ShutdownFile_echoWave_2eproto();

class echoWave;
class echoWaveRequest;
class echoWaveResponse;

// ===================================================================

class echoWave : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:echoWave) */ {
 public:
  echoWave();
  virtual ~echoWave();

  echoWave(const echoWave& from);

  inline echoWave& operator=(const echoWave& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const echoWave& default_instance();

  enum MessageCase {
    kRequest = 1,
    kResponse = 2,
    MESSAGE_NOT_SET = 0,
  };

  void Swap(echoWave* other);

  // implements Message ----------------------------------------------

  inline echoWave* New() const { return New(NULL); }

  echoWave* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const echoWave& from);
  void MergeFrom(const echoWave& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(echoWave* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .echoWaveRequest request = 1;
  bool has_request() const;
  void clear_request();
  static const int kRequestFieldNumber = 1;
  const ::echoWaveRequest& request() const;
  ::echoWaveRequest* mutable_request();
  ::echoWaveRequest* release_request();
  void set_allocated_request(::echoWaveRequest* request);

  // optional .echoWaveResponse response = 2;
  bool has_response() const;
  void clear_response();
  static const int kResponseFieldNumber = 2;
  const ::echoWaveResponse& response() const;
  ::echoWaveResponse* mutable_response();
  ::echoWaveResponse* release_response();
  void set_allocated_response(::echoWaveResponse* response);

  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:echoWave)
 private:
  inline void set_has_request();
  inline void set_has_response();

  inline bool has_message() const;
  void clear_message();
  inline void clear_has_message();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  union MessageUnion {
    MessageUnion() {}
    ::echoWaveRequest* request_;
    ::echoWaveResponse* response_;
  } message_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_AddDesc_echoWave_2eproto();
  friend void protobuf_AssignDesc_echoWave_2eproto();
  friend void protobuf_ShutdownFile_echoWave_2eproto();

  void InitAsDefaultInstance();
  static echoWave* default_instance_;
};
// -------------------------------------------------------------------

class echoWaveRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:echoWaveRequest) */ {
 public:
  echoWaveRequest();
  virtual ~echoWaveRequest();

  echoWaveRequest(const echoWaveRequest& from);

  inline echoWaveRequest& operator=(const echoWaveRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const echoWaveRequest& default_instance();

  void Swap(echoWaveRequest* other);

  // implements Message ----------------------------------------------

  inline echoWaveRequest* New() const { return New(NULL); }

  echoWaveRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const echoWaveRequest& from);
  void MergeFrom(const echoWaveRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(echoWaveRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string wave = 1;
  void clear_wave();
  static const int kWaveFieldNumber = 1;
  const ::std::string& wave() const;
  void set_wave(const ::std::string& value);
  void set_wave(const char* value);
  void set_wave(const char* value, size_t size);
  ::std::string* mutable_wave();
  ::std::string* release_wave();
  void set_allocated_wave(::std::string* wave);

  // @@protoc_insertion_point(class_scope:echoWaveRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr wave_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_echoWave_2eproto();
  friend void protobuf_AssignDesc_echoWave_2eproto();
  friend void protobuf_ShutdownFile_echoWave_2eproto();

  void InitAsDefaultInstance();
  static echoWaveRequest* default_instance_;
};
// -------------------------------------------------------------------

class echoWaveResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:echoWaveResponse) */ {
 public:
  echoWaveResponse();
  virtual ~echoWaveResponse();

  echoWaveResponse(const echoWaveResponse& from);

  inline echoWaveResponse& operator=(const echoWaveResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const echoWaveResponse& default_instance();

  void Swap(echoWaveResponse* other);

  // implements Message ----------------------------------------------

  inline echoWaveResponse* New() const { return New(NULL); }

  echoWaveResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const echoWaveResponse& from);
  void MergeFrom(const echoWaveResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(echoWaveResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  bool status() const;
  void set_status(bool value);

  // optional string echo = 2;
  void clear_echo();
  static const int kEchoFieldNumber = 2;
  const ::std::string& echo() const;
  void set_echo(const ::std::string& value);
  void set_echo(const char* value);
  void set_echo(const char* value, size_t size);
  ::std::string* mutable_echo();
  ::std::string* release_echo();
  void set_allocated_echo(::std::string* echo);

  // @@protoc_insertion_point(class_scope:echoWaveResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool _is_default_instance_;
  ::google::protobuf::internal::ArenaStringPtr echo_;
  bool status_;
  mutable int _cached_size_;
  friend void  protobuf_AddDesc_echoWave_2eproto();
  friend void protobuf_AssignDesc_echoWave_2eproto();
  friend void protobuf_ShutdownFile_echoWave_2eproto();

  void InitAsDefaultInstance();
  static echoWaveResponse* default_instance_;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// echoWave

// optional .echoWaveRequest request = 1;
inline bool echoWave::has_request() const {
  return message_case() == kRequest;
}
inline void echoWave::set_has_request() {
  _oneof_case_[0] = kRequest;
}
inline void echoWave::clear_request() {
  if (has_request()) {
    delete message_.request_;
    clear_has_message();
  }
}
inline  const ::echoWaveRequest& echoWave::request() const {
  // @@protoc_insertion_point(field_get:echoWave.request)
  return has_request()
      ? *message_.request_
      : ::echoWaveRequest::default_instance();
}
inline ::echoWaveRequest* echoWave::mutable_request() {
  if (!has_request()) {
    clear_message();
    set_has_request();
    message_.request_ = new ::echoWaveRequest;
  }
  // @@protoc_insertion_point(field_mutable:echoWave.request)
  return message_.request_;
}
inline ::echoWaveRequest* echoWave::release_request() {
  // @@protoc_insertion_point(field_release:echoWave.request)
  if (has_request()) {
    clear_has_message();
    ::echoWaveRequest* temp = message_.request_;
    message_.request_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void echoWave::set_allocated_request(::echoWaveRequest* request) {
  clear_message();
  if (request) {
    set_has_request();
    message_.request_ = request;
  }
  // @@protoc_insertion_point(field_set_allocated:echoWave.request)
}

// optional .echoWaveResponse response = 2;
inline bool echoWave::has_response() const {
  return message_case() == kResponse;
}
inline void echoWave::set_has_response() {
  _oneof_case_[0] = kResponse;
}
inline void echoWave::clear_response() {
  if (has_response()) {
    delete message_.response_;
    clear_has_message();
  }
}
inline  const ::echoWaveResponse& echoWave::response() const {
  // @@protoc_insertion_point(field_get:echoWave.response)
  return has_response()
      ? *message_.response_
      : ::echoWaveResponse::default_instance();
}
inline ::echoWaveResponse* echoWave::mutable_response() {
  if (!has_response()) {
    clear_message();
    set_has_response();
    message_.response_ = new ::echoWaveResponse;
  }
  // @@protoc_insertion_point(field_mutable:echoWave.response)
  return message_.response_;
}
inline ::echoWaveResponse* echoWave::release_response() {
  // @@protoc_insertion_point(field_release:echoWave.response)
  if (has_response()) {
    clear_has_message();
    ::echoWaveResponse* temp = message_.response_;
    message_.response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void echoWave::set_allocated_response(::echoWaveResponse* response) {
  clear_message();
  if (response) {
    set_has_response();
    message_.response_ = response;
  }
  // @@protoc_insertion_point(field_set_allocated:echoWave.response)
}

inline bool echoWave::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void echoWave::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline echoWave::MessageCase echoWave::message_case() const {
  return echoWave::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// echoWaveRequest

// optional string wave = 1;
inline void echoWaveRequest::clear_wave() {
  wave_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& echoWaveRequest::wave() const {
  // @@protoc_insertion_point(field_get:echoWaveRequest.wave)
  return wave_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void echoWaveRequest::set_wave(const ::std::string& value) {
  
  wave_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:echoWaveRequest.wave)
}
inline void echoWaveRequest::set_wave(const char* value) {
  
  wave_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:echoWaveRequest.wave)
}
inline void echoWaveRequest::set_wave(const char* value, size_t size) {
  
  wave_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:echoWaveRequest.wave)
}
inline ::std::string* echoWaveRequest::mutable_wave() {
  
  // @@protoc_insertion_point(field_mutable:echoWaveRequest.wave)
  return wave_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* echoWaveRequest::release_wave() {
  // @@protoc_insertion_point(field_release:echoWaveRequest.wave)
  
  return wave_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void echoWaveRequest::set_allocated_wave(::std::string* wave) {
  if (wave != NULL) {
    
  } else {
    
  }
  wave_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), wave);
  // @@protoc_insertion_point(field_set_allocated:echoWaveRequest.wave)
}

// -------------------------------------------------------------------

// echoWaveResponse

// optional bool status = 1;
inline void echoWaveResponse::clear_status() {
  status_ = false;
}
inline bool echoWaveResponse::status() const {
  // @@protoc_insertion_point(field_get:echoWaveResponse.status)
  return status_;
}
inline void echoWaveResponse::set_status(bool value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:echoWaveResponse.status)
}

// optional string echo = 2;
inline void echoWaveResponse::clear_echo() {
  echo_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& echoWaveResponse::echo() const {
  // @@protoc_insertion_point(field_get:echoWaveResponse.echo)
  return echo_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void echoWaveResponse::set_echo(const ::std::string& value) {
  
  echo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:echoWaveResponse.echo)
}
inline void echoWaveResponse::set_echo(const char* value) {
  
  echo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:echoWaveResponse.echo)
}
inline void echoWaveResponse::set_echo(const char* value, size_t size) {
  
  echo_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:echoWaveResponse.echo)
}
inline ::std::string* echoWaveResponse::mutable_echo() {
  
  // @@protoc_insertion_point(field_mutable:echoWaveResponse.echo)
  return echo_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* echoWaveResponse::release_echo() {
  // @@protoc_insertion_point(field_release:echoWaveResponse.echo)
  
  return echo_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void echoWaveResponse::set_allocated_echo(::std::string* echo) {
  if (echo != NULL) {
    
  } else {
    
  }
  echo_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), echo);
  // @@protoc_insertion_point(field_set_allocated:echoWaveResponse.echo)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_echoWave_2eproto__INCLUDED
